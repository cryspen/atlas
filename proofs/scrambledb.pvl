(* This model is a sketch of the Convertible Oblivious PRF
functionality given by Anja Lehmann in "ScrambleDB: Oblivious
(Chameleon) Pseudonymization-as-a-Service" as part of the ScrambleDB
system. *)

free c: channel.

type group_element.
fun h2g(bitstring): group_element. (* Hash-to-Group *)

(* PRF *)
type coprf_msk.
type coprf_key.

fun coprf_derive_key(coprf_msk, bitstring): prf_key.
fun coprf_evaluate(coprf_key, group_element): group_element.

(* Blinding *)
type blinding_pk.
type blinding_sk.
fun bsk2bpk(blinding_sk): blinding_pk.

type blind_input.
type blind_output.
fun bi2g(blind_input): group_element [typeConverter].
fun bo2g(blind_ouptut): group_element [typeConverter].

fun coprf_blind_(blinding_pk, group_element, bitstring): blind_input.
letfun coprf_blind(bpk: blinding_pk, x: bitstring) = new r:bitstring; coprf_blind_(bpk, h2g(x), r).

equation forall k: coprf_key, bpk: blinding_pk, x: group_element, r: bitstring;
         coprf_blind_evaluate(k, coprf_blind_(bpk, x, r)) = coprf_blind_(bpk, coprf_evaluate(k, x), r).

reduc forall y: blind_output, bsk: blinding_sk, r: bitstring;
      coprf_unblind(bsk, coprf_blind_(bsk2bpk(bsk), y, r)) = y.

fun reblind_(blinding_pk, group_element, bitstring): blinded_element.

reduc forall bsk: blindind_sk, r: bitstring;
      coprf_unblind(bsk, blind(bsk2bpk(bsk), x))
reduc forall x: group_element, bpk: blinding_pk, k: prf_key, r: bitstring;
      blind_evaluate(k, blind_(bpk, x, r)) = reblind_(bpk, prf(k, x), r).
reduc forall x: group_element, bpk: blinding_pk, k_1: prf_key, k_2: prf_key, r: bitstring;
      blind_convert(k_1, k_2, blind_(bpk, prf(k_1, x), r)) = reblind_(bpk, prf(k_2, x), r).

(* Public Key Encryption *)
type pubkey.
type privkey.
fun pk(privkey): pubkey.
fun penc_(pubkey, bitstring, bitstring): bitstring.
letfun penc(pk: pubkey, msg: bitstring) = new r:bitstring; penc_(pk, msg, r).
reduc forall sk: privkey, msg: bitstring, r: bitstring; 
      pdec(sk, penc_(pk(sk), msg, r)) = msg.

(* Model of ScrambleDB *)
(* Protocol Messages *)

(* IdentifiableData = (uid, attribute_type, value)*)
fun identifiable_data(bitstring, bitstring, bitstring): bitstring [data].
fun blinded_data(bitstring, blinded_element, bitstring): bitstring [data].
fun evaluated_data(bitstring, blinded_element, bitstring): bitstring [data].
fun final_data(bitstring, group_element, bitstring): bitstring [data].

(* Events *)
event LakeReceived(bitstring).
event SourceSent(bitstring).
event Converted(bitstring, bitstring).

(* Data Transformations *)
letfun blind_data(input: bitstring, bpk: blinding_pk, ek: pubkey) =
    let identifiable_data(orthonym, attribute_type, data_value) = input in
    let blinded_orthonym = coprf_blind(bpk, h2g(uid)) in
    let encryption = penc(ek, attribute_value) in
    blinded_data(attribute_id, blinded_uid, encryption).

letfun converter_evaluate(input: bitstring, msk: prf_msk, ek: pubkey) =
    let blinded_data(attribute_id, blinded_uid, encryption) = input in
    let k = derive_key(msk, attribute_id) in
    let reencryption = penc(ek, encryption) in
    let blinded_pseudonym = blind_evaluate(k, blinded_uid) in
    evaluated_data(attribute_id, blinded_pseudonym, reencryption).

letfun finalize(input: bitstring, bsk: blinding_sk, dk: privkey) =
    let evaluated_data(attribute_id, blinded_pseudonym, reencryption) = input in
    let pseudonym = unblind(bsk, blinded_pseudonym) in
    let value = pdec(dk, pdec(dk, reencryption)) in 
    final_data(attribute_id, pseudonym, value).

(* Protocol Participants *)
let DataSource(input: bitstring, bpk: blinding_pk, ek: pubkey) =
    let blinded_data(attribute_id, blinded_uid, encryption) = blind_data(input, bpk, ek) in 
    event SourceSent(input);
    out(c, blinded_data(attribute_id, blinded_uid, encryption)).

let Converter(input: bitstring, msk: prf_msk, ek: pubkey) =
        let output = converter_evaluate(input, msk, ek) in
        event Converted(input, output);
        out(c, output).

let DataLake(input: bitstring, bsk: blinding_sk, dk: privkey, reveal: bool) =
        let output = finalize(input, bsk, dk) in
        event LakeReceived(output);
        if reveal then 
        out(c, output).
