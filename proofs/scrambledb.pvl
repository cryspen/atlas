(* This model is a sketch of the Convertible Oblivious PRF
functionality given by Anja Lehmann in "ScrambleDB: Oblivious
(Chameleon) Pseudonymization-as-a-Service" as part of the ScrambleDB
system. *)

free c: channel.

(* PRF *)
type prf_msk.
type prf_key.
type group_element.
fun hash_to_group(bitstring): group_element.
fun derive_key(prf_msk, bitstring): prf_key.
fun prf(prf_key, group_element): group_element.

(* Blinding *)
type blinding_pk.
type blinding_sk.
type blinded_element.
fun blinding_sk_to_pk(blinding_sk): blinding_pk.
fun blind_(blinding_pk, group_element, bitstring): blinded_element.
fun reblind_(blinding_pk, group_element, bitstring): blinded_element.
letfun blind(bpk: blinding_pk, x: group_element) = new r:bitstring; blind_(bpk, x, r).
reduc forall y: group_element, bsk: blinding_sk, r: bitstring;
      unblind(bsk, reblind_(blinding_sk_to_pk(bsk), y, r)) = y.
reduc forall x: group_element, bpk: blinding_pk, k: prf_key, r: bitstring;
      blind_evaluate(k, blind_(bpk, x, r)) = reblind_(bpk, prf(k, x), r).
reduc forall x: group_element, bpk: blinding_pk, k_1: prf_key, k_2: prf_key, r: bitstring;
      blind_convert(k_1, k_2, blind_(bpk, prf(k_1, x), r)) = reblind_(bpk, prf(k_2, x), r).

(* Public Key Encryption *)
type pubkey.
type privkey.
fun pk(privkey): pubkey.
fun penc_(pubkey, bitstring, bitstring): bitstring.
letfun penc(pk: pubkey, msg: bitstring) = new r:bitstring; penc_(pk, msg, r).
reduc forall sk: privkey, msg: bitstring, r: bitstring; 
      pdec(sk, penc_(pk(sk), msg, r)) = msg.

(* Model of ScrambleDB *)
(* Protocol Messages *)
fun input_data(bitstring, group_element, bitstring): bitstring [data].
fun blinded_data(bitstring, blinded_element, bitstring): bitstring [data].
fun evaluated_data(bitstring, blinded_element, bitstring): bitstring [data].
fun final_data(bitstring, group_element, bitstring): bitstring [data].

(* Events *)
event LakeReceived(bitstring).
event SourceSent(bitstring).
event Converted(bitstring, bitstring).

(* Data Transformations *)
letfun blind_data(input: bitstring, bpk: blinding_pk, ek: pubkey) =
    let input_data(attribute_id, uid, attribute_value) = input in
    let blinded_uid = blind(bpk, uid) in
    let encryption = penc(ek, attribute_value) in
    blinded_data(attribute_id, blinded_uid, encryption).

letfun converter_evaluate(input: bitstring, msk: prf_msk, ek: pubkey) =
    let blinded_data(attribute_id, blinded_uid, encryption) = input in
    let k = derive_key(msk, attribute_id) in
    let reencryption = penc(ek, encryption) in
    let blinded_pseudonym = blind_evaluate(k, blinded_uid) in
    evaluated_data(attribute_id, blinded_pseudonym, reencryption).

letfun finalize(input: bitstring, bsk: blinding_sk, dk: privkey) =
    let evaluated_data(attribute_id, blinded_pseudonym, reencryption) = input in
    let pseudonym = unblind(bsk, blinded_pseudonym) in
    let value = pdec(dk, pdec(dk, reencryption)) in 
    final_data(attribute_id, pseudonym, value).

(* Protocol Participants *)
let DataSource(input: bitstring, bpk: blinding_pk, ek: pubkey) =
    let blinded_data(attribute_id, blinded_uid, encryption) = blind_data(input, bpk, ek) in 
    event SourceSent(input);
    out(c, blinded_data(attribute_id, blinded_uid, encryption)).

let Converter(input: bitstring, msk: prf_msk, ek: pubkey) =
        let output = converter_evaluate(input, msk, ek) in
        event Converted(input, output);
        out(c, output).

let DataLake(input: bitstring, bsk: blinding_sk, dk: privkey, reveal: bool) =
        let output = finalize(input, bsk, dk) in
        event LakeReceived(output);
        if reveal then 
        out(c, output).


